#!/usr/bin/perl

use Modern::Perl;
use utf8;

BEGIN {
    use FindBin;
    eval { use lib $FindBin::Bin; };
}

use C4::Context;
use C4::Biblio;
use MARC::Record;
use ConversionTable::BiblionumberConversionTable;

my $verbose = $ARGV[0];


my $biblionumberConversionTable = ConversionTable::BiblionumberConversionTable->new('biblionumberConversionTable', 'read');
#Find the biblionumber from where the Biblio importing started, eg. the first Biblionumber for this import batch.
my $lowestBiblionumber = $biblionumberConversionTable->lowestKey();
$lowestBiblionumber = $biblionumberConversionTable->fetch($lowestBiblionumber);
#$lowestBiblionumber = 75000;


#For Pielinen we don't need to realign the 773$w -> 001 linking because 001 has the database id
# of the legacy system. Only the new biblionumber in Koha is different from old legacy id, but in-MARC
# linkings are correct.
#realign773w();



sub realign773w {
###  FIND THE IMPORTED COMPONENT PARTS AND REALIGN THE 773$w TO USE THE NEW CONVERTED BIBLIONUMBERS  ###
#Get all new Component Parts.
my $dbh = C4::Context->dbh();
my $sth = $dbh->prepare("
SELECT bi.biblionumber, bi.marcxml, b.frameworkcode
FROM biblioitems bi LEFT JOIN biblio b ON b.biblionumber = bi.biblionumber
WHERE bi.biblionumber >= ? AND bi.marcxml REGEXP 'tag=\"773\"'
");
$sth->execute($lowestBiblionumber);
my $realignableComponentParts = $sth->fetchall_arrayref({});

#UPDATE the 773$w
my $sthUpdate = $dbh->prepare("
UPDATE biblioitems bi
SET bi.marcxml = ?
WHERE bi.biblionumber = ?
");
print "Updating Component Childrens' 773\$w linking to Component Parent\n";
for (my $i=0 ; $i<@$realignableComponentParts ; $i++) {
    if($i % 1000 == 0){
        print "\n$i";
    }

    my $cp = $realignableComponentParts->[$i];

    if($cp->{marcxml} =~ m/(<datafield tag="773".+?>)(.+?)(<\/datafield>)/s) {
        my $f773head = $1;
        my $f773subfields = $2;
        my $f773tail = $3;
        if ($f773subfields =~ m/(.+?<subfield code="w">)(.+?)(<\/subfield>.+?)/s) {
            #Sanitate search patterns and replace patterns separately.
            #We cannot use special characters like [(/?*+{. in the search pattern, but we
            #must preserve them in the replace pattern.
            #I know this is awkward but this is over 10x faster than using the Koha internal API.
            my $b1 = $1;
            my $a1 = sanitateRegexp($1);
            my $a2 = sanitateRegexp($2);
            my $b3 = $3;
            my $a3 = sanitateRegexp($3);
            my $parentBiblionumber = $2;
            $parentBiblionumber =~ s/\D//g; #Remove all non-digits, eg. garbage generated by usemarcon.
            my $newParentBiblionumber = $biblionumberConversionTable->fetch($parentBiblionumber) if $parentBiblionumber;

            if ($newParentBiblionumber) {
                print "---------------------------------------------\n".$cp->{marcxml}."\n" if $verbose;
                $cp->{marcxml} =~ s/$a1$a2$a3/$b1$newParentBiblionumber$b3/s;
                $sthUpdate->execute($cp->{marcxml}, $cp->{biblionumber}); #This is FAST!!
                print $cp->{marcxml}."\n" if $verbose;
            }
        }
    }
}
}


#There are 12 special characters for regexps, we need to sanitate them all:
#
#    backslash \, the caret ^, the dollar sign $, the period or dot ., the vertical bar or
#    pipe symbol |, the question mark ?, the asterisk or star *, the plus sign +,
#    the opening parenthesis (, the closing parenthesis ), and the opening square bracket [,
#    the opening curly brace {, These special characters are often called "metacharacters".
#
sub sanitateRegexp {
    my $string = shift;
    $string =~ s/\\|\/|\^|\$|\||\?|\*|\+|\(|\)|\[|\{/./sg;
    return $string;
}
